---
title: すごいH-1
date: 2018-02-21T05:29:37.000Z
categories:
  - 読書メモ
id: "17391345971618387580"
draft: false
---
# sugoih-1
## すごいH本1章のメモです
### 免責事項
このメモに記載されている解釈の正しさについては保証されていません．

### 1.2
- Haskellにおけるifは式
  - 値の未定義は許されない（うまくやると許されたりするのかもしれないが現状の自分にとっては許されない）
  - else節が必要
- ifは式として評価値を返すので，`(if ... then ... else ...) + 1`みたいな演算が出来る（型が一致さえしてれば演算結果が未定義にならないことが保証される）
  - すごい
- Haskellの関数名で先頭大文字は許されない
- 慣習的に，関数名の最後に`'`を付けるのは以下のどちらかの場合に利用される
  - 正格（遅延じゃない）関数
  - 少し変更したバージョン
- `conanO'Brien = "hogehoge..."`の辺り
  - 文字列変数の定義に見えるが，これは引数を取らず定数を返す関数である
  - haskellの変数（みたいに見えるやつ）は全部こういう解釈なんですか（わかってない）
  - 「関数が1つも値を取らない時，これを定義とか名前とか呼びます．」

### 1.3
- ghciの新し目のバージョンだと名前を定義する際にletはいらない
  - [https://qiita.com/Aruneko/items/e72f7c6ee49159751cba:embed]
- リストの連結: `++`
  - `[1,2,3] ++ [4,5,6] -- [1,2,3,4,5,6]`
  - `"hello " ++ "world" -- "hello world"`
  - haskellにおいて文字列は文字のリストになってるのでリストの関数が使える
- リストの先頭に要素を追加する: `:`
  - `1:[2,3,4] -- [1,2,3,4]`
  - `++`は必ず2つのリストを受けるが，:は単一の要素とリストを受ける
  - 軽い
  - `[1,2,3]`は`1:2:3:[]`の糖衣構文
- リスト内のn番目の要素を取り出す: `!!`
  - `[1,2,3] !! 1 -- 2`
- リストを要素として持つリストを作れる（数字とか文字みたいに揃ってれば）
- リストの比較は辞書順
  - `<, >=`とかで比較できる
  - 空でないリストは空のリストより常に大きい
- `head, tail, last, init`
  - `head`: リストの先頭の要素を返す
  - `tail`: 先頭要素を除いたリストを返す
  - `last`: 最後の要素を返す
  - `init`: 最後の要素を除いたリストを返す
  - これらは空リストを渡すとエラーになる
- リストの長さを返す/空か判定: `length/null`
  - `length [] -- 0`
  - `null [] -- True`
- 逆順にしたリストを返す: `reverse`
  - `reverse [] -- []`
    - エラーにならない
- 先頭からn個の要素を取り出したリストを返す: `take`
  - `take 3 [1,2,3,4,5] -- [1,2,3]`
  - `take 3 [] -- []`
    - エラーにならない
  - `take 0 [1,2,3] -- []`
  - `take 10000 [1,2,3] -- [1,2,3]`
    - 要素数より多い個数を取り出そうとすると，リスト全体を返す
- 先頭からn個を取り除いたリストを返す: `drop`
  - `drop 100 [1,2,3] -- []`
- (順序が定義されている要素のリストに関して）最大要素最小要素を返す: `maximum/minimum`
  - 空リストを渡すとエラー
- 数のリストの各要素の和/積を計算: `sum/product`
  - `sum [1,2,3] -- 6`
  - `product [4,5,6] -- 120`
  - `sum [] -- 0`
  - `product [] -- 1`
    - !?
    - `product [1,2,3]`が`product 1:2:3:[]`の糖衣構文であり，これがなんらかの関数fを用いて`f(1)*f(2)*f(3)*f([])`として評価されていると仮定すると，この計算結果が`0`でなくなるために`f([])=1`となっていて，これが`product [] -- 1`となっている理由？（わかってないです）
    - `sum/product`が計算できるようなリストの要素には和や積が定義されていて，`sum/product []`はそれぞれ加法/乗法単位元を返している？
- あるリストがある要素を含んでいるか？: `elem`
  - わかりやすいので中置で書くことが多い？
  - ``2 `elem` [1,2,3] -- True``
  - ``100 `elem` [1,2,3] -- False``

### 1.4
- range
  - `[1..20] -- [1,2,...,20]`
  - `[1..] -- [1,2,...]`
    - `take`しないと無限に出る
  - `[2,4..20] -- [2,4,6,8,...,20]`
    - 等差数列でないと厳しい
    - 減少は`[20,18..2]`のように書く
- リストを無限に繰り返す: `cycle`
  - `cycle [1,2,3] -- [1,2,3,1,2,3,1,2,3,...]`
  - 文字列もいける
- 要素を無限に繰り返す: `repeat`
- `replicate n k = take n (repeat k)`
- rangeを浮動小数点で使うとやばそう

### 1.5
リスト内包表記について（さっぱりわからない，雰囲気でやっている）

- `[x*2 | x <- [1..10]] -- [2,4,...,20]`
  - `[1..10]`から各要素を取り出して`*2`した要素のリスト
- `[x*2 | x <- [1..10], x*2 >= 12] -- [12,14,...,20]`
  - `[1..10]`から*2したら12以上になるような要素を取り出してリストにして返す
  - または`[1..10]`から取り出した要素の内*2したら12以上になるようなものだけをフィルタリングしてリストにして返す
  - 恐らく後者？
  - 取り出しとリストにして返却を過程として分けて考えるのは恐らく正しくなくて，取り出しつつ順次リストとして返却しているような（感覚的な表現）
    - 遅延評価よく分からなくて泣いてます😥
- リスト内包表記の条件部分を述語という
- ``[x | x <- [50..100], x `mod` 7 == 3] -- [52,59,66,...,94]``
  - 50から100の数の内，7で割った余りが3であるようなすべての数のリスト
- 複数のリストから値を取り出すことも出来る
  - `[x+y | x <- [リスト1], y <- [リスト2]]`
  - x, yの可能な組み合わせ全てについてx+yが計算されリストとして返される
- リストの長さを得る関数の独自定義`length'`
  - `length' xs = sum [1 | _ <- xs]`
  - 使わない値は_に突っ込むのちょくちょく見ますね

### 1.6
- タプル
  - 複数の型の要素を格納できる
  - `(50, 50.4, "hello", 'b')`
- 長さが違うタプルは別の型
  - `(1,2)`と`(4,5,6)`は別の型
- 長さが一緒で格納されている型が違うタプルは別の型
  - `(1,2)`と`("one", 2)`は別の型
- ペア(長さ2のタプル)
  - `fst, snd`が使える
  - `fst (1,2) -- 1`
  - `snd (1,2) -- 2`
- 2つのリストを組み合わせてペアのリストを返す: `zip`
  - `zip [1,2,3,4,5] [5,5,5,5,5] -- [(1,5),(2,5),(3,5),(4,5),(5,5)]`
  - `zip [1] [5,5,5] -- [(1,5)]`
    - 長さが違う時は短い方に合わせられる
  - `zip [] [5,5,5] -- []`
  - 無限リストとも`zip`できる
